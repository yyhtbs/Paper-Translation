# NDSS2017快速而私密地结算支付：基于路径的交易的高效分散式路由

## 摘要

分散式基于路径的交易（PBT）网络维护参与者之间的本地支付通道。成对的用户利用这些通道通过中介途径结算支付，而无需在全球区块链中记录所有交易。PBT网络，例如比特币的闪电网络和以太坊的Raiden网络，是这一新兴研究领域中最突出的例子。这两个网络通过用廉价且快速的**链下交易**代替昂贵且缓慢的链上操作，克服了广泛使用的加密货币的可扩展性问题。**分散式PBT网络的核心是路由算法**，该算法可发现发送方和接收方之间的交易路径。近年来，已经提出了许多路由算法，包括在分散的IOU资金额度网络SilentWhispers和Flare（闪电网络的链路状态算法）中使用的地标路由。但是，现有的工作缺乏**效率**或**私密性**，全面的分析对于确保PBT网络在实践中成功是必不可少的。在这项工作中，我们首先讨论分散式PBT网络的现有路由算法中的几个效率问题。掌握了这些知识后，我们设计并评估了SpeedyMurmurs，这是一种用于分散式PBT网络的新型路由算法，它使用基于嵌入（Embedding-based）的高效灵活的路径发现和按需高效稳定化（On-demand Efficient Stabilization）来处理PBT网络的动态。我们基于来自当前部署的Ripple配额网络（Credit Network）的真实数据进行的模拟研究表明，SpeedyMurmurs**将稳定的开销减少了两个数量级**，而**路由的开销则减少了两倍以上**。此外，使用SpeedyMurmurs至少可以保持与分散式地标路由**相同的成功率**，同时提供较低的延迟。最后，SpeedyMurmurs实现了分散PBT网络中路由的关键隐私目标。

## 介绍

自比特币[19]出现以来，已经提出并在实践中部署了许多其他基于区块链的支付系统，以达到多种目的。例如，IOweYou（IOU）资金额度网络 [3]，[7]（例如Ripple [1]或Stellar [32]）利用区块链技术来实现不同货币和资产的两个最终用户之间的实时总结算 [25]。比目前的中央银行系统便宜很多。以太坊 [6]在区块链之上构建了一个平台从而运行完全功能性的智能合约。

但是，用户和交易基础的增长导致了区块链可扩展性问题 [2]，[21]。此外，区块链的公共性导致明显的隐私数据泄露，例如**交易对方的身份和交易量** [9]，[13]，[14]，[18]，[26]。学术界和行业的努力正在导致点对点（P2P）基于路径的交易（PBT）网络的发展，例如针对比特币的闪电网络[21]，针对以太坊的Raiden网络[24]，针对以太坊的SilentWhispers [11]资金额度网络，或用于区块链间交易的InterLedger [33]和Atomic-swap [10]；这些分散的PBT网络有望通过不需要昂贵的挖矿工作的链下交易解决区块链的可扩展性，效率和互操作性问题。实际上，在最近的区块链事件中，Inter-Ledger团队通过七个区块链（包括比特币，以太坊和瑞波币[36]）演示了一项交易。

与基于区块链的PBT网络（如Ripple或Stellar）不同，去中心化PBT网络中的两个用户 $u$和$v$ 在本地维护加权链路（基于应用场景，也称为支付通道，状态通道或资金额度链路）。链路的权重描述了一个用户可以转移给另一用户的资金（或资产）的数量，链路的确切性质取决于应用场景。例如，在资金额度网络中，权重定义了$u$愿意授予 $v$ 的资金额度量与$v$已欠$u$的量之间的差。

PBT网络建立在三个关键算法之上：路由（Routing），支付（Payment）和责任追究（Accountability）。

* 路由算法负责查找从发送者到接收者的具有足够资金的路径。
* 支付算法沿连接发送方和接收方的路径结算资金。
* 责任追究算法可以在存在行为不端的用户的情况下解决纠纷。

虽然路由算法的设计经常被忽略或忽视，但是它是影响PBT网络有效性，效率，可扩展性的关键因素。

* 有效性:成功完成交易的比例
* 效率:交易期间的延迟以及交易产生的开销
* 可扩展性:在不断增长的用户和交易需求下，保持有效性和效率。

尽管业界认为有效性，效率和可扩展性是设计路由算法的主要考虑因素，但我们另外强调了隐私的必要性。否则，路由算法可能会泄露敏感信息，例如交易量，发送者和接收者的身份以及**一个用户对另一个用户的债务**。在本文中，我们强调所有有效性，效率，可扩展性和隐私性对于路由算法的设计都至关重要。缺少任何这些关键属性的路由算法都不太可能部署。

迄今为止，为PBT网络提出的几种路由算法都无法实现私密性，效率或可扩展性。一些例子包括，

* Ripple和Stellar中的**路由算法依赖于记录完整PBT网络的公共区块链**，从而引入了1）区块链费用并2）泄露了隐私。
* Canal [35] 依靠一台服务器来存储完整的PBT网络，查找路径并结算用户之间的支付。因此，服务器可以轻松了解用户及其交易之间的所有关系。
* PrivPay [17] 利用受信任的硬件在服务器上加密PBT网络数据，并使用简单的算法隐藏访问模式，从而增加了用户与其支付之间的链路的隐私性。尽管如此，PrivPay仍然遭受单点故障和低可扩展性的困扰。
* Flare [23] 是闪电网络的路由算法，它要求从发送者到接收者的路径中的每个用户将其支付通道的当前资金金额发送给发送者，从而泄漏敏感信息 [23] 。
* 关于隐私的最有前途的方法是SilentWhispers [11]，这是一个没有公共分类帐的去中心化PBT网络。但是，正如我们在本文中所显示的，SilentWhispers中的路由算法缺乏效率。

在这项工作中，我们介绍了SpeedyMurmurs，这是一种用于PBT网络的路由算法，可以在完全分布式的环境中提供正式的隐私保证，并且在有效性和效率方面均优于最新的路由算法。**SpeedyMurmurs扩展了VOUTE** [30] ，这是一种基于隐私保护，基于嵌入的 [20] 路由算法，用于在路由受限的P2P网络中进行消息传递。VOUTE的目标是在无方向性和非加权网络（而不是支付）中发送消息，因此它不具备处理加权链路的功能，尤其是由于先前传输而导致的这些权重的变化。SpeedyMurmurs将VOUTE的基本思想与Credit网络的特定特征相结合。特别是：

* 在路由支付时，SpeedyMurmurs会同时考虑**可用资金**和与**目的地距离**，从而形成具有灵活路径选择的高效算法。
* SpeedyMurmurs采用按需高效稳定算法，该算法在必要时**对链路的更改做出反应**，但保持与这些更改相对应的开销较低。
* SpeedyMurmurs通过允许**节点主动分配一笔交易所需的资金量**，而不是阻止并发交易完全使用链路或在随后的支付阶段中冒失败的风险，从而改进了对并发交易的处理。
* 在我们的模拟研究中，基于2013年至2016年间Ripple的真实世界数据集对资金额度网络和交易进行建模，SpeedyMurmurs的交易速度大约是SilentWhispers的两倍，并将交易的通信开销降低了至少两倍。两个同时保持相似或更高的效果。
* SpeedyMurmurs将Ripple数据集中与突然快速增长相对应的稀有阶段（每年大约一个）除外，将管理链路更改的开销减少了2-3个数量级。
* SpeedyMurmurs实现了价值隐私，即隐蔽了交易价值和发送者和接收者的身份。

总而言之，SpeedyMurmurs为PBT网络中的隐私保护路由提供了有效，高效且可扩展的解决方案，因此成为此类网络即将部署的有希望的候选人。我们发布的初步结果引发了有关在闪电网络环境中部署SpeedyMurmurs或相关算法的讨论。

## SOTA和限制

我们首先简要概述一下PBT网络的概念。然后，我们介绍了地标路由和基于嵌入的路由的概念，包括对SilentWhispers [11]（基于地标路由的PBT网络）和VOUTE [30]（基于嵌入的路由算法）的描述，我们对其进行了调整 到第四节中的PBT网络。

### PBT 网络

在PBT网络中，一对用户在本地维护与区块链应用相关的支付通道。例如，在闪电网络中，两个用户通过在区块链中添加定金交易来创建通道，并通过本地调整余额来更新通道状态。闪电网络从而减少了区块链上的负载，它已成为扩展比特币最有希望的替代方案。

PBT网络中的支付操作涉及中间用户的路径，该中间用户成对调整其链路以有效地结算发送方和接收方之间的资金。在Lightning Network中，通过交易，每个中间节点量从先继节点获取的存款。同样，她将给后继节点支付相同金额。但是，如果没有首先通过路由算法找到满足条件的路径，就无法完成支付。

### 地标路由 （Landmark Routing）

地标路由技术 [34] 能够计算PBT网络中**发送方和接收方之间的路径子集**，而无需依赖于成本高昂的最大流方法。地标路由的关键思想是确定通过中间节点（称为地标，通常是众所周知的高连接性节点）从发送者到接收者的路径。使用几个这样的地标增加了发送者和接收者之间的计算路径的数量。因为地标路由不会发现所有可能的路径，可能导致成功支付的成功的概率下降。过去的工作表明，与性能提升相比，成功率的损失很小 [17]，[35]。

最初，每个地标都会启动广度优先搜索（BFS）算法的两个实例，从而产生两个生成树。在第一实例下，仅考虑前向边缘，并计算从**一个地标到每个节点**的最短路径。第二个实例仅考虑反向边缘，并导致**每个节点与任意地标之间的路径最短**。当PBT网络随时间变化时，地标会定期重复此初始化过程。然后，发送方和接收方之间的路径发现将从发送方到地标的路径（使用反向边）和从地标到接收方的路径（使用正向边）连接起来。只要支付金额不高于路径上每个链路上的可用额度，发送方就可以沿路径发送资金。

地标路由有两种版本。我们将第一个版本（称为地标中心）始终连接从源到地标以及从地标到目的地的路径。第二个版本，我们称为纯树路由，发现了BFS树中最短的路径，它不一定包含地标。

一）SilentWhispers中的地标路由：SilentWhispers利用以**地标中心**的路由发现多条路径，然后通过**多方计算（MPC）**以确定沿每条路径发送的资金量。地标路由的初始化遵循上面的描述，使用多个地标（每个地标周期性执行BFS）。

实际支付取决于两个操作：1\) 探测操作和2\) 实际支付操作。我们在此称之为“探测操作”，因为它执行路由并决定要沿每个路径转移的余额。然后，支付操作使用基于安全探测的路径。

探测操作的核心是基于秘密共享的多方计算，该计算可算出路径中的可用额度。使用地标路由发现连接发送者和接收者之间的路径后，路径中的每对相邻节点都会将其通道的额度发送给每个地标。发送者和接收者必须构造充当填充的其他部分，以隐藏路径的实际长度，**并有效保留实际发送者和接收者的身份**。借助密码签名，依靠新密钥来**隐藏路径上节点的身份**，并使用多方计算，地标确定发送者可以组合以获得第 $i$条路的最小可以用额度 $z_i$ 。如果额度的总和 $\sum z_i$ 大于等于总支付量，则发送方分配值 $c_1 \dots c_{|L|}$ 到满足的路径$c_1 \leq z_i$。探测操作的结果是这些值 $c_i$和相关的路径，支付操作可利用这些探测到的路径执行转帐操作。

二）SilentWhispers的弱点：基于以上描述，我们列举了四个SilentWhispers实现的问题。

* 首先，定期树的创建（BFS的执行）无法支持网络中的突然变化，因为信息过时，系统有比较高的故障率。此外，由于对可能未更改的PBT网络部分进行重新计算，因此定期创建树会引起不必要的开销。
* 第二，由于SilentWhispers依赖于以地标为中心的路由，因此即使1）付款的发送方和接收方在同一分支中，或者，2）发送方和接收方之间存在比较短的路径（path），但某些链路（links）却不是地标生成树的一部分。因此，用于支付的总路径可能不必要地被延长，导致更大的延迟和更低的成功率，这是因为在没有足够资金的情况下遇到至少一个链路的机会增加了。
* 第三，探测操作要求交易路径中包含的节点将配额发送到所有地标。这意味着交易开销在地标数量上成倍增加。
* 第四，SilentWhispers没有提供合适的并发解决方案。假设存在多个交易探测同一链路。探测操作可以

  * 1）为两次探测提供相同的可用配额值。
  * 2）在探测操作第一次找到包含链路的路径后的一段时间内阻止使用该链路。

  前者可能会导致第二个交易的失败，因为可用的配额虽然足以满足每次转移所需的费用，但可能无法覆盖多次支付。对于后者，尽管一段时间阻止交易降低了这种不确定性，但同时增加了交易失败的可能性。这是英文在探测过程中会发现某些链路无法使用，及时这些链路可能具有足够的配额来执行多个交易。因此，两种并发方法都具有严重的缺陷。

总而言之，我们旨在克服SilentWhispers中的各种弱点。

### 基于嵌入的路由

P2P-PBT网络不同于普通的P2P网络，因为节点之间的连接是预定义的，**并且不能更改**。由于这种固定的结构，P2P-PBT网络受到路由限制，因此与Friend-to-Friend（F2F）网络密切相关，后者将只允许连接到互信的节点。我们总结了F2F网络中最先进的路由方法，即基于嵌入的路由 [20], [30] 。

**嵌入方法**依赖于将**坐标**分配给网络中的节点，并使节点根据该节点已知的坐标与目标坐标之间的距离转发数据包。**贪婪嵌入与地标路由类似**，它们基于节点在生成树中的位置来分配坐标。但是，贪婪嵌入会在分配坐标后**忽略生成树**，尤其可能会使用不在生成树中的链路。我们将生成树中未包含的链路称为“捷径”。当节点 $v$ 转发消息到目标坐标时，它选择坐标最接近目标的邻居并以将消息转发至该节点。因此，路由可能使用生成树中的链路或捷径。

尽管路径可以包含捷径，但不能保证路径总存在捷径。因此，树中的链路保证了路由基本功能。删除任何此类链路可能会导致故障。在没有捷径的情况下，基于嵌入的路由与纯树形路由相同。因此，树的结构需要在节点或链路更改及时调整。

## 前缀嵌入

前缀嵌入（Prefix Embedding）[8] 是一种贪婪的嵌入方法，它的目的是在F2F覆盖网络（overlay）中路由消息。如图1所示，“前缀嵌入”以矢量形式分配坐标，从地标/根处的空 开始。

生成树的每个内部节点都枚举其子级，并将子级的枚举索引附加到其坐标中以获得子级坐标。两个这样的坐标之间的距离对应于它们之间的生成树中最短路径的长度。即两个坐标 $id(u)$ 和$id(v)$的距离，其中$|id(w)|$表示节点w的坐标长度，而公共前缀长度表示为 $2cpl \left( id(u),id(v)\right)$ 。

$
d \left( id(u),id(v)\right)= |id(u)|-cpl \left( id(u),id(v)\right) \\
-|id(v)|-cpl \left( id(u),id(v)\right) \\
=|id(v)|+|id(u)|-2cpl \left( id(u),id(v)\right)
$

基于等式如图1所示，节点根据其坐标距离确定哪个邻居最接近接收者，并相应地转发消息。图1显示了一个示例，以说明各种基于树的路由方案之间的差异，并说明“前缀嵌入”中的坐标分配。

![&#x56FE;1 &#x8DEF;&#x6807;lm&#xFF0C;&#x53D1;&#x9001;&#x65B9;s&#xFF0C;&#x63A5;&#x6536;&#x65B9;r&#x7684;&#x4E0D;&#x540C;&#x751F;&#x6210;&#x6811;&#x8DEF;&#x7531;&#x65B9;&#x6848;&#x7684;&#x793A;&#x4F8B;&#x3002;](.gitbook/assets/image%20%286%29.png)

#### VOUTE中的前缀嵌入

VOUTE [30]是一种基于前缀嵌入的路由算法，其目的是为动态路由受限的网络匿名和高效地传递消息；即不允许在任意节点之间建立链路的网络。我们将快速描述VOUTE如何解决隐私和动态问题。

前缀嵌入揭示了接收器的唯一坐标。相反，VOUTE允许节点提供匿名返回地址而不是其原始坐标。接收方通过将坐标填充到固定长度并生成坐标元素的键控哈希值来生成返回地址。然后，匿名返回地址由元组（带键的哈希，键）组成，其中键允许转发节点确定Eq中所需的公共前缀长度。1.根据接收方坐标 $id(r)$ 和邻居坐标 $id(u)$ 的公共前缀长度，转发节点可以计算距离 $d(id(u), id(r)) + ∆$ 。$∆$ 是填充后的坐标长度（常数）。因此，他们可以沿着明发送所用的路径发送消息，同时保持接收者真实坐标的私密性。

原始的前缀嵌入可以通过枚举表示，因此熵很小。结果，VOUTE用随机的 $b \text{-bit}$替换了原来的枚举索引；例如，$b =128$ 。以这种方式，猜测未知节点的坐标对于敌手来说，在计算上变得不可行。

VOUTE无需定期重建生成树，而是使用**按需的**稳定算法解决动态问题。构造树时，节点向所有邻居发送邀请，说明其坐标并表示愿意成为父节点。每个节点都接受一个这样的邀请。通过记录所有邻居的最新邀请以快速地对网络动态进行响应。如果节点建立新链路，则生成树中已包含的节点会向其新邻居发出邀请。如果节点还不是树的一部分，则它接受邀请。否则，它将存储它以供将来考虑。另一方面，如果生成树中的链路不再存在，则子节点及其所有后代将根据剩余的邀请来选择新的父节点。然后，他们向所有邻居散布新坐标。以这种方式，生成树和嵌入具有**按需修复**的机制，**而不是像标志性路由那样具有周期性的完全重新计算**。

#### VOUTE的限制

VOUTE尚未在PBT网络的情景中定义，因此存在一些限制，在将其视为PBT网络中的路由算法之前必须克服这些限制。特别是，对于PBT网络中的链路和拓扑动态，VOUTE具有不兼容的问题。

首先，VOUTE考虑用户对之间的无方向性和非加权链路。相对的，在PBT网络中，付款需要对链路进行定向和加权。虽然所有链路都允许在VOUTE中进行消息传输，但是PBT网络中的某些链路可能没有足够的资金来完成付款。在PBT中，VOUTE算法不能满足需求，因为尚不清楚如何处理单向链路。如果单向链路是生成树的一部分，则节点（及其后代）可能只能发送或接收资金，而不能同时发送或接收资金。1）链路存在权重以及2）无法使用链路来完成所有付款的特性与VOUTE算法的关键假设（即在没有链路失败的情况下，所有链路都可以传输消息）之一背道而驰。因此，为了在PBT网络中应用VOUTE，有必要设计支持加权链路和传输的算法。

其次，VOUTE考虑节点加入和离开网络的动态情况。但是，在PBT网络中，链路的权重是变化的主要的动态来源。每个成功的交易可能会更改几个链路的权重。如果修改VOUTE从而支持所有这些需求，则可能会导致算法效率低下。确定何时以及如何对变化的链路进行自适应调整对于算法设计来说很重要。

最后，VOUTE不必处理并发问题。虽然并发消息传输可能会增加延迟和拥塞，但它们不会更改链路的容量，并且传输消息不会影响链路传输未来消息的能力。但是，像SilentWhispers一样，分开进行探测和支付操作会导致并发问题。SilentWhispers提供的解决方案存在不足，因此我们需要一种新的并发算法。

总而言之，尽管VOUTE是一种用于替代SilentWhispers中地标路由的有趣方案，但其在PBT网络场景中并非一劳永逸。

## SpeedyMurmurs算法构成

在本节中，我们首先描述设计的关键思想，然后详细介绍路由算法中的三个操作。我们为集中控制算法提供了伪代码，以紧凑的方式展示算法。然后，我们描述在PBT网络中使用的分布式与集中式算法的区别。

### 假设

PBT网络中的每个用户都在本地**维护与其邻居的链路信息**。我们进一步假设共享链路的用户可以通过身份验证的机密通信通道相互发送消息。而且，我们假设存在一组称为地标的节点，这些节点对于PBT网络中的用户是公开的。我们注意到这些假设与诸如SilentWhispers之类的其他分布式PBT网络是一致的。

在本节中，我们将双向都具有非零资金的链路称为双向（即链路$(u, v)$和$(v, u)$，满足$w(u, v)>0$且$w(v, u) > 0$）。如果两个链路之一不存在或资金为零，则$u$和$v$简化为单向链路。

### 核心思想

这里描述SpeedyMurmurs中setRoutes，setCred和routePay操作的核心思想。

setRoutes：在此算法中，我们构造了多个嵌入，每个嵌入对应一个地标。如第II-C节所述，VOUTE提供了一种用于基于BFS的坐标分配的算法，该算法假定网络使由未加权和未定向的链路组成。我们通过两个阶段来修改VOUTE算法。第一阶段，我们添加双向链路。第二阶段，我们把尚未加入生成树的节点通过单向链路添加到生成树中。

setCred：我们首先更改链路的权重，然后相应地调整嵌入。由于VOUTE不支持对权重的变化作出响应。为了与setRoutes一致，我们决定仅在以下两点进行更改：

* 1\) 建立了权重非零的新链路（或将链路的值从0设置为非零值）。
* 2\) 删除了无权重（权重为0）的链路（或将其值设置为0）。

在建立了新链路过程重，如果一个结点没有父节点，或它到其当前父节点的链路**仅在一个方向上**具有资金额度，则这个节点可以选择另一个作为父节点。相反，当一条链路被删除了，对于一个节点，如果存在历史的父节点（并非当前的父节点），那么这个节点选择其中一个节点作为新的父节点。此外，受影响节点的任何子节点都必须更改坐标。

routePay：路由包括三个步骤：

* 1\) 接收方生成一些**匿名返回地址（anonymous return addresses）**，并将其发给发送方。
* 2\) 发送方在$|l|$上随机分割交易值。路径，每个地标对应一条路径。
* 3\) VOUTE的路由算法在发送方和接收方之间**找到一条有足够资金路径**。我们的算法允许灵活地选择路线，而选择资金较高的路线。

预先确定每沿个路径转移的资金，使节点可以在探测操作期间冻结一定数量的资金。这样不是冻结链路的所有资金，所以不影响后续的正常支付。

### 具体细节

> 算法 1 $setRoutes()$  #生成一个路由树
1： # Input: Graph $G$, landmarks $l_1 \dots l_{|L|}$
2：**for** $i = 1$ to $|L|$ **do**:
3：$\qquad$ $id_i(l_i)$ = ()
4：$\qquad$ $q = \text{new } queue()$ # 初始化一个空对列
5：$\qquad$ $q.push(l_i)$   # 把$l_i$加入$q$中
6：$\qquad$ $b_i = True$    # 首先考虑有双向边的节点
7：$\qquad$ **while** $q.size() \neq 0$ **do**:
8：$\qquad$$\qquad$ $m = q.pop()$      # $m$ is actually the same as $l$
9：$\qquad$$\qquad$ **for** $\forall n \in m.\text{neighbors} $ **do**:
10：$\qquad$$\qquad$$\qquad$ $n$ stores $id_i(m)$
11：$\qquad$$\qquad$$\qquad$ # Assign coordinate **if** $n$ does ***NOT*** have one
12：$\qquad$$\qquad$$\qquad$ **if** $id_i(n) == null$ **then**: # $n$没有地标
13：$\qquad$$\qquad$$\qquad$$\qquad$ **if** $(w(m, n) > 0 \text{ AND } w(n, m) > 0) \text{ OR } b_i == False$ **then**:
14：$\qquad$$\qquad$$\qquad$$\qquad$$\qquad$ $parent_i(n) = m$
15：$\qquad$$\qquad$$\qquad$$\qquad$$\qquad$ $r = randBit.gen(b)$ #b-bit
16：$\qquad$$\qquad$$\qquad$$\qquad$$\qquad$ $id_i(n) = concatenate(id_i(m), r)$
17：$\qquad$$\qquad$$\qquad$$\qquad$$\qquad$ $q.push(n)$
18：$\qquad$$\qquad$**if** $q.size() == 0$ ***AND*** $b_i == True$ **then**: # 给节点加上单向边
19：$\qquad$$\qquad$$\qquad$ $b_i = False$
20：$\qquad$$\qquad$$\qquad$ $q.push([n: id_i(n) == q])$

#### $setRoutes$：
在算法1所述的初始化阶段，我们得出嵌入。遍历所有地标，算法1将地标$l_i$的**坐标**$id_i(l_i)$初始化为空矢量（第3行），并将地标加入到队列$q$（第5行）。然后，算法的主循环处理队列。在每个步骤中，算法都会从队列中删除一个节点$m$（第8行），并考虑其所有邻居$n$。如果邻居$n$还没有坐标并且有资格获得一个坐标，则该算法会将$n$添加到生成树中，通过将父坐标和一个随机的b位数字连接来分配坐标，并将其附加到队列中（14-17）。确定是否属于扩展范围的标准取决于算法的阶段：最初（$b_i = true$，第6行），如果到其潜在父节点的链路上的可用资金额度不为零，则该节点是合格的。在算法的第二阶段$(b_i = false)$，由空队列触发（第18-20行），所有节点都可以加入生成树。请注意，算法1不会阻止子节点选择父节点，以使他们在任一方向上都没有资金。由于此类链路在PBT网络中没有任何作用，因此我们假定该网络不允许它们。算法1可以在允许建立生成树路由（父子关系）之前检查单向链路上的资金是否满足非零。当队列为空时，该算法即终止，这确保了所连接图中的所有节点都具有坐标。

在分布式方案中，没有中央队列。因此，节点在加入生成树时会向其邻居发送消息。每个消息都包括树的索引$i$和潜在父节点的坐标$id_i(m)$。在分布式方案中，第二阶段非常棘手，因为并非所有节点都会同时启动。为此，我们设定一个时间限制$τ$，它代表初始化所需时间的上限。如果节点$n$从**只有一个权重非零的链路的**邻居$m$接收到消息$(i, id_i(m))$，则节点$n$等待时间$τ$。如果$n$的邻居中没有一个与$n$之间存在双向链路，这表明它们在等待期结束前可能是$n$父对象，则$n$选择$m$节点作为其父对象。

> 算法 2 $setCred()$ # 解决动态图
1: # Input: Graph $G$, $u, v \in V$ , new value $c$
2: $old = w(u, v)$ # Previous value of w(u, v)
3: # check if coordinate change necessary
4: for i = 1 to |L| do
5: $\qquad$reset = null # node whose coordinate should change
6: $\qquad$# case: add link
7: $\qquad$if old == 0 and c > 0 then
8: $\qquad$# If one node does not have a coordinate
9: $\qquad$if idi(v) is not set and idi(u) is set then
10: $\qquad$reset = v
11: $\qquad$if idi(u) is not set and idi(v) is set then
12: reset = u
13: # One node has unidirectional link to parent
14: if reset = null then
15: if w(u, v) > 0 and w(v, u) > 0 then
16: a1 = w(u, $parent_i$ (u)) == 0 or w($parent_i$ (u), u) == 0
17: a2 = w(v, $parent_i$ (v)) == 0 or w($parent_i$ (v), v) == 0
18: if a1 and !a2 then
19: reset = v
20: if a2 and !a1 then
21: reset = u
22: # case:remove link
23: if old > 0 and c == 0 then
24: if $parent_i$ (u) == v then
25: reset = u
26: if $parent_i$ (v) == u then
27: reset = v
28: # change coordinates
29: if reset != null then
30: delete coordinates of reset and descendants
31: have nodes choose new pare

#### $setCred$：
setCred对希望将其共享链路的值更改为c的一对节点$(u，v)$作出反应。算法2首先确定值更改是否应导致坐标更改。总共有三种情况表明需要更改坐标：

1）新的非零单向链路：其中一个节点尚未成为树的一部分，因此应选择另一个作为其父节点（第8-12行），以便能够参与路由。

2）新的非零双向链路：$u$和$v$共享双向非零链路，并且（不失一般性）$u$仅具有到其当前父节点的单向链路。然后，如果$v$具有与其父节点的双向链路，则应将其父节点更改为$v$（第13-21行）。这样，双向连接将替代生成树中的单向链路，并增加成功转移资金的可能性

3）删除的链路：$u$是$v$的子节点或$v$是$u$的子节点（第24–27行）。子节点应选择一个新的父节点，以增加生成树中非零链路的数量以及转移资金的可能性。

如果$u$或$v$中的一个更改其父节点，则所有后代都删除其坐标，并将删除通知其邻居。然后，他们都选择一个新的父节点和相应的坐标。与初始化setRoutes一致，节点首先仅考虑在两个方向上都具有非零链路的邻居。但是，如果节点没有到任何邻居的此类链路，则它会考虑一个方向的链路。如果他们有几个合适的父节点，他们会从那些坐标最短的候选人中随机选择他们的父节点，因为到地标的路径很短会减少路径的长度[30]。选择新坐标后，节点将新坐标和树索引转发给所有邻居。我们不提供伪代码，因为它与算法非常相似

算法2的分布式变体遵循相同的原理，但是需要交换消息以供节点传达信息。$u$和$v$交换有关其父节点链路的信息。然后，他们每个人都各自决定是否要添加或删除另一个作为父项。从旨在重置其坐标的节点重置开始，所有后代首先通知其邻居，他们删除了树i的旧坐标。节点的子节点依次删除其自己的坐标并发送相应的消息。在第二阶段，节点选择其新坐标并通知其邻居。由于这两个阶段可能在分布式设置中并行运行，因此节点必须确保在后代选择新坐标之前，它们不要选择前一个后代作为父代。但是，坐标的性质使得通过禁止节点$v$选择其坐标包含$v$的先前坐标的父节点作为prefix，可以很容易地防止树中的此类循环。

#### $routePay$：
routePay探测从发送者到接收者的一组路径。它对应于SilentWhispers中的探针操作。算法3将过程分为三个步骤：

1. 生成接收方地址（第2-5行）

接收方为所有地标生成匿名返回地址$addr_1 \dots addr_{|l|}$，并将其发送给发送方（第2-5行）。

2. 在$|L|$上随机选择某些路径，总交易值满足$c$

发送方在所有路径之上随机分配交易值（第7行）。通过在路由之前定义每条路径的值，我们不但避免了SilentWhispers的昂贵的多方计算，并且允许算法在几种可能的路由之间进行选择。避免多方计算所需的最小值也可以消除隐私泄漏，因为知道完整路径上可用资金的最小值有时会揭示有关各个链接的信息

3. 为所有嵌入找到可传递所需价值$c_l$的路径。

路由发现从$v$开始，每个节点选择一个邻居作为路由上的下一个节点。在VOUTE中，每个节点将使用$\tilde d$函数将坐标与匿名返回地址进行比较，从而选择**最接近**目的地的邻居。但是，这种设计不一定适合传输资金，因为该链路可能没有足够的可用额度。结果，设计的路由算法仅考虑有足够可用金额度的链路$(v, u)$（$w_A(v, u)\geq c_i$，第14行）。我们区分**可用资金额度**$w(v, u)$和**保证金额度**$w_A(v, u)$来处理并发问题。如果正在进行的探测操作成功，则使用保证金$w_A$作为下界。最初（没有探测事件），$w_A$等于实际可用资金额度$w$。我们没有在算法3中包括初始化，因为routePay的多个并发执行会影响$w_A(v, u)$，并且算法一开始就满足$w_A(v, u) < w(v, u)$。如果通过探测，确定付款将沿着$(v, u)$传输资金$c_i$，我们会对$(v, u)$主动降低保证可用资金额度$w_A(v, u)-c_i$（第17行），以防止将来的路由过载该链路。如果路由失败，我们将$c_i$再次添加回$w_A(v, u)$（第21-23行）。如果节点$v$找不到更接近目的地且链路有足够保证的可用资金额度的邻居，则路由失败。

> Algorithm 3 routePay
1: # Input: Graph G, sender src, receiver dst, value c
2: # get addresses
3: for i = 1 to |L| do
4: use VOUTE’s algorithm to generate return address addi(dst)
5: dst sends addi(dst) to src
6: # value shares for each path
7: src splits c into shares c1, . . . , c|L|
8: # routing
9: pathi = empty list of links
10: for i = 1 to |L| do
11: v = src
12: fail = false
13: while !fail and v != dst do
14: C = {u ∈ N(v) : ˜d(idi(u), addi(dst)) < ˜d(idi(u), addi(dst)), wA(v, u) ≥ ci}
15: if C not empty then
16: next = u in C with minimal ˜d(idi(u), addi(dst))
17: wA(v, u) = wA(v, u) − ci
18: v = next
19: else
20: fail = true # Routing failed
21: if routing failed then
22: for all i = 1 . . . |L|, e ∈ pathi do
23: wA(e) = wA(e) + ci

算法3能够满足正确性，是因为：
1. $\sum_{i = 1} ^ {|L|}c_i = c$
2. 节点始终在第$i$个路径上选择链路$(u, v)$，满足$w(u, v) \geq w_A(u, v) \geq c_i$，即资金不会过度使用。   

在算法3的分布式变体中，节点将消息发送到路径上的下一个节点，该消息包含地址$addr_i$和部分值$c_i$。节点通过沿反向路径发送消息来向发送方报告失败和成功。为了解决丢失的消息，如果支付操作在一定时间内未遵循探测操作，则节点还会重置$w_A$。

### 参数

几个参数控制上述路由算法的性能。首先，数字$|L|$地标的数量确定返回路径的数量。交易和稳定开销大约$|L|$线性增长。因为每个地标都需要路由和稳定。类似地，延迟对应于任何嵌入中的最长路径，因此可能会随着$|L|$而增加。$|L|$的影响成功率的高低很大程度上取决于方案。第二个参数是交易尝试的次数$a$。发送者最多可以尝试执行$a$次交易。仅当所有尝试均失败时，$s$才认为交易失败。tl是两个连续尝试之间的时间间隔。重复的交易尝试对相同的发送者，接收者和值执行上述路由算法，但使用不同的配额分配$c_1 \dots c_{|L|}$ 。除了参数$|L|$，$a$和$t_l$外，地标的选择还会影响性能。通常，地标是金融机构提供的节点，因此具有大量的链路，可能导致生成深度较低，性能更高的生成树。我们在性能评估中描述了这些参数的影响。

### 隐私分析

接下来，我们认为SpeedyMurmurs实现了III-C节中提出的隐私目标。

价值隐私：非正式地，我们说如果对手无法确定两个不妥协的用户u和v之间的$routePay(c, u, v)$操作的值$c$，则PBT网络将获得价值隐私。涉及的路由路径。

SpeedyMurmurs是一个分布式PBT网络，尤其是，定义routePay使得仅涉及发送者和接收者之间路径中的用户。因此，如果对手不妥协任何此类用户，则她不会获得有关路由值的任何信息（因为点对点通信已加密），从而实现了值的私密性。

当对手在发送者和接收者之间的某些路径（但不是全部）中破坏用户时，出现另一种情况。在这种情况下，我们无法阻止对手估算$c$。因为我们对于所有$i = 1$的$c_i≥0 \dots |L|$，知道这些值的子集自然会揭示有关总值$c$的信息，即$c≥c_i$。此外，由于SpeedyMurmurs在路径之间均匀地共享值$c$并仅使用正份额，因此对手可以将$c$估计为$|L|∗c_i$观察$c_i$。

发送者隐私：非正式地说，如果对手无法在$routePay(c, u, v)$操作中确定发送者$u$，则我们可以说PBT网络实现了发送者隐私。对手可能会在$routePay(c, u, v)$发现的路径上危害中间用户，但不会危害$u$或$v$。坐在发送方$s$和接收方$r$之间的路径上的攻击者可能会收到匿名路由地址$add_i$（例如，对手设法破坏了发送者的邻居）。但是，由于SpeedyMurmurs是分布式PBT网络，对手无法确定实际发送者是通过直接链路还是通过非受感染用户的路径连接到的另一个用户或另一个用户。发送者的隐私来自VOUTE [29]的相应证明。

接收者隐私：我们非正式地说，如果对手无法通过$routePay(c, u, v)$操作确定接收者$v$，那么PBT网络就可以实现接收者隐私。对手可能会损害$routePay(c, u, v)$发现的路径上的中间用户，但不会损害$u$或$v$。

如前所述，在接收者$r$可能中继给$r$匿名返回地址之前，攻击者折衷于用户。但是，如VOUTE的评估所示，匿名返回地址不会泄漏网络中的相应用户。因此，对手还不能完全确定$r$是否是实际的接收者，或者路由消息是否打算通过直接链路或不受影响的用户的路径连接到$r$的另一个接收者$r'$。

### 总结

在本节中，我们介绍了SpeedyMurmurs，它提出了用于PBT网络的隐私保护路由算法。我们在修改VOUTE以适应资金额度网络情况方面的主要贡献是：i）使用两阶段构造算法来考虑单向链路的存在（算法1），ii）确定何时按需应用标准维护（算法2），iii）设计路径发现算法，该算法可以根据可用资金额度和相邻节点的坐标自适应地选择链路，并可以处理并发性（算法3）。除了使用基于嵌入的路由外，SpeedyMurmurs通过在路径发现之前在路径之间分配资金额度来将自己与SilentWhispers区分开。通过这种方式，节点可以根据其应转发的资金额度额度（而不只是邻居到目的地的距离）做出转发决策。另一方面，在路径发现之前分配资金会阻止算法考虑路径上的全部可用资金。在下一部分中，我们将评估设计决策对效率和有效性的影响，尤其是分析路由和资金分配顺序与成功率之间的关系。
